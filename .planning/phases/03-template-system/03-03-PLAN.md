---
phase: 03-template-system
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - app/api/checklists/instantiate/route.ts
  - app/checklists/new/page.tsx
  - prisma/schema.prisma
autonomous: true

must_haves:
  truths:
    - "User can select one or more templates to combine"
    - "User can name the new checklist"
    - "Merged checklist contains all items from selected templates"
    - "Items appear in order based on template selection order"
    - "Items show which template they came from"
    - "Duplicate items across templates appear only once"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "Checklist and ChecklistItem models"
      contains: "model Checklist"
    - path: "app/api/checklists/instantiate/route.ts"
      provides: "Checklist creation with merge logic"
      exports: ["POST"]
    - path: "app/checklists/new/page.tsx"
      provides: "Template selection and instantiation UI"
      min_lines: 80
  key_links:
    - from: "app/checklists/new/page.tsx"
      to: "/api/templates"
      via: "fetch to load template list"
      pattern: "fetch.*api/templates"
    - from: "app/checklists/new/page.tsx"
      to: "/api/checklists/instantiate"
      via: "POST with selected template IDs and checklist name"
      pattern: "fetch.*api/checklists/instantiate.*POST"
    - from: "app/api/checklists/instantiate/route.ts"
      to: "prisma.checklist"
      via: "transaction creating checklist and items"
      pattern: "prisma\\.\\$transaction"
---

<objective>
Build checklist instantiation functionality that merges multiple templates into a unified checklist with deduplication, preserving template source information and selection order.

Purpose: Deliver the core value proposition - fast, frictionless checklist creation from reusable templates (INST-01, INST-02, INST-03)
Output: Working merge API with deduplication logic and template selection UI
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-template-system/03-template-system-CONTEXT.md

# Prior plan in this phase
@.planning/phases/03-template-system/03-01-SUMMARY.md

# Key files
@prisma/schema.prisma
@auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Checklist models and build merge API</name>
  <files>
prisma/schema.prisma
app/api/checklists/instantiate/route.ts
  </files>
  <action>
First, extend the Prisma schema with Checklist and ChecklistItem models, then create the instantiation API endpoint.

**Prisma schema additions:**

Add to User model: `checklists Checklist[]`

**Checklist model:**
- id: String @id @default(cuid())
- name: String (user-provided checklist name)
- userId: String (foreign key to User)
- createdAt: DateTime @default(now())
- updatedAt: DateTime @updatedAt
- user: User relation
- items: ChecklistItem[] relation

**ChecklistItem model:**
- id: String @id @default(cuid())
- text: String (checklist item text)
- completed: Boolean @default(false) (for Phase 4)
- order: Int (position in checklist, 0-indexed)
- sourceTemplate: String (name of template this item came from)
- checklistId: String (foreign key to Checklist)
- createdAt: DateTime @default(now())
- checklist: Checklist relation

Run `npx prisma db push` and `npx prisma generate` after schema changes.

**API endpoint (app/api/checklists/instantiate/route.ts):**

POST endpoint that accepts:
- name: string (checklist name)
- templateIds: string[] (array of template IDs in selection order)

Logic:
1. Authenticate user via getServerSession
2. Fetch all specified templates with items (verify user owns all templates, return 404 if any missing/not owned)
3. Merge items preserving selection order:
   - Iterate templateIds in order
   - For each template, append its items (sorted by order field)
   - Track item text for deduplication (case-sensitive exact match)
   - If item text already seen, skip (first occurrence wins - per CONTEXT.md)
   - For each unique item, create ChecklistItem with: text, order (sequential), sourceTemplate (template name)
4. Use Prisma transaction to create Checklist and all ChecklistItem records atomically
5. Return created checklist with items included

Return 400 if templateIds empty, 401 if not authenticated, 404 if templates not found/not owned.
  </action>
  <verify>
Test merge logic with curl:
- Create 3 templates via API with overlapping items
- Template A: ["Item 1", "Item 2", "Item 3"]
- Template B: ["Item 2", "Item 4"]
- Template C: ["Item 5", "Item 1"]
- POST to /api/checklists/instantiate with templateIds [A, B, C]
- Verify response has items in order: Item 1 (from A), Item 2 (from A), Item 3 (from A), Item 4 (from B), Item 5 (from C)
- Item 2 from B should be skipped (duplicate)
- Item 1 from C should be skipped (duplicate)
  </verify>
  <done>
Checklist and ChecklistItem models exist in database. Instantiate API endpoint merges templates correctly, deduplicates items, preserves selection order, and stores source template information.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create checklist instantiation UI</name>
  <files>app/checklists/new/page.tsx</files>
  <action>
Create the checklist instantiation page at /checklists/new that allows template selection and checklist naming.

**Page structure:**
- Protected route (auth check)
- Fetch all user templates on mount from /api/templates
- Display list of templates with checkboxes or multi-select UI (your discretion per CONTEXT.md)
- Checklist name input field (required)
- Selected templates display in selection order (visual feedback showing order matters)
- "Create Checklist" button
- Empty state if no templates exist: "No templates available. Create templates first." with link to /templates/new

**Template selection:**
- Multiple selection allowed (checkboxes or multi-select list)
- At least 1 template required (disable Create button if none selected)
- Show count of selected templates
- Selection order visualization (numbered badges showing 1st, 2nd, 3rd selected OR list showing order)

**Checklist creation flow:**
1. User selects templates (order tracked)
2. User enters checklist name
3. Click "Create Checklist"
4. POST to /api/checklists/instantiate with {name, templateIds: [ordered array]}
5. On success: redirect to checklist view page (for now, redirect to homepage with success message)
6. On error: display error message

**Preview option (your discretion per CONTEXT.md):**
Optionally show preview of merged items before creating. If implemented: fetch templates, run merge logic client-side (deduplicate and order), show preview list. If skipped: direct creation without preview.

**Styling:**
- Use established Tailwind patterns
- Responsive layout
- Clear visual hierarchy showing selection order matters
- Disabled states for buttons when validation fails
  </action>
  <verify>
Test instantiation flow:
1. Visit /checklists/new
2. Verify templates load from API
3. Select 2-3 templates in specific order
4. Enter checklist name "My Workflow"
5. Click Create Checklist
6. Verify POST to API with correct template order
7. Confirm redirect happens on success
8. Check database that checklist was created with merged items

Test edge cases:
- No templates selected: Create button disabled or shows validation error
- Empty checklist name: validation prevents submission
- No templates exist: empty state with link to create template
  </verify>
  <done>
Checklist instantiation page exists, loads templates, allows selection with order tracking, validates input, creates checklist via API, and handles success/error states. User can select multiple templates and see that order matters.
  </done>
</task>

</tasks>

<verification>
1. Checklist and ChecklistItem models exist in database
2. Instantiate API correctly merges templates in selection order
3. Deduplication works: duplicate items appear only once (first occurrence)
4. Source template is stored for each item
5. Instantiation UI loads templates and allows ordered selection
6. Created checklist contains all merged items in correct order
7. End-to-end flow: select templates -> name checklist -> create -> redirect
</verification>

<success_criteria>
- User can select multiple templates to combine (INST-01)
- User can name the new checklist (INST-02)
- User can create checklist from selected templates with all items merged (INST-03)
- Items appear in order based on template selection order (per CONTEXT.md)
- Duplicate items are automatically deduplicated (per CONTEXT.md)
- Each item shows which template it came from (per CONTEXT.md)
- At least 1 template is required (per CONTEXT.md)
- API and UI handle validation and error cases gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/03-template-system/03-03-SUMMARY.md`
</output>
