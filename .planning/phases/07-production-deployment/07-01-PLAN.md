---
phase: 07-production-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [Dockerfile, .dockerignore, scripts/migrate-and-start.sh]
autonomous: true

must_haves:
  truths:
    - "Application builds successfully in Docker container"
    - "Prisma migrations run before Next.js starts"
    - "Container image uses multi-stage build for optimization"
  artifacts:
    - path: "Dockerfile"
      provides: "Multi-stage build configuration"
      contains: "FROM node:alpine"
      min_lines: 30
    - path: ".dockerignore"
      provides: "Build context exclusions"
      contains: "node_modules"
    - path: "scripts/migrate-and-start.sh"
      provides: "Migration entrypoint script"
      contains: "prisma migrate deploy"
      min_lines: 10
  key_links:
    - from: "Dockerfile"
      to: "scripts/migrate-and-start.sh"
      via: "ENTRYPOINT or CMD"
      pattern: "scripts/migrate-and-start\\.sh"
    - from: "scripts/migrate-and-start.sh"
      to: "prisma"
      via: "shell script execution"
      pattern: "prisma.*migrate.*deploy"
---

<objective>
Create Docker foundation for containerized deployment with optimized multi-stage build and automated Prisma migrations.

Purpose: Enable application to run in Docker containers for local development and production deployment. Migrations must run automatically at startup to ensure database schema is current without manual intervention.

Output: Dockerfile with multi-stage build, migration entrypoint script, and .dockerignore for optimized builds
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-production-deployment/07-CONTEXT.md

# Current project files
@package.json
@prisma/schema.prisma
@.env.example

# Phase context decisions
- Prisma migrations run at container startup (before Next.js starts)
- Use node:alpine for minimal image size
- Multi-stage build: dependencies -> builder -> production
- DATABASE_URL from environment variable (docker-compose network or Azure)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create multi-stage Dockerfile</name>
  <files>Dockerfile</files>
  <action>
Create a production-ready Dockerfile with multi-stage build using node:alpine base image.

Stages:
1. **dependencies**: Install all dependencies (including devDependencies for building)
2. **builder**: Build Next.js application (prisma generate, next build)
3. **runner**: Production image with only runtime dependencies

Key requirements:
- Use node:20-alpine as base
- Install Prisma CLI in runner stage (needed for migrations)
- Copy prisma schema and migrations folder to runner
- Set NODE_ENV=production
- Expose port 3000
- Create non-root user for security
- Use ENTRYPOINT to run migration script (will be created in Task 2)

Follow Next.js Docker best practices from official docs.
  </action>
  <verify>
```bash
docker build -t extensible-checklist:test .
docker image ls | grep extensible-checklist
```
Build should complete without errors. Check image size is reasonable (under 500MB).
  </verify>
  <done>
Dockerfile exists with three stages (dependencies, builder, runner), uses node:alpine, exposes port 3000, and references migration script as entrypoint
  </done>
</task>

<task type="auto">
  <name>Task 2: Create migration entrypoint script</name>
  <files>scripts/migrate-and-start.sh</files>
  <action>
Create shell script that runs Prisma migrations before starting Next.js server.

Script logic:
1. Run `prisma migrate deploy` to apply pending migrations
2. Exit if migrations fail (do NOT start app with broken schema)
3. If migrations succeed, start Next.js with `node server.js`

Add executable permissions: `chmod +x scripts/migrate-and-start.sh`

Include error handling:
- If DATABASE_URL not set, print error and exit
- If migration fails, print error and exit with code 1
- Log migration success before starting app

Use `set -e` to exit on first error.

Note: Next.js standalone output puts server at `.next/standalone/server.js` - script should start from that location.
  </action>
  <verify>
```bash
cat scripts/migrate-and-start.sh
test -x scripts/migrate-and-start.sh && echo "Executable" || echo "Not executable"
```
Script should contain prisma migrate deploy, error handling, and next start command. File should be executable.
  </verify>
  <done>
Migration script exists at scripts/migrate-and-start.sh, is executable, runs prisma migrate deploy before starting Next.js, and exits if migrations fail
  </done>
</task>

<task type="auto">
  <name>Task 3: Create .dockerignore file</name>
  <files>.dockerignore</files>
  <action>
Create .dockerignore to exclude unnecessary files from Docker build context.

Exclude:
- node_modules (will be installed fresh in container)
- .next (will be built in container)
- .git (not needed in image)
- .planning (project docs, not needed at runtime)
- .env (secrets should come from environment, not baked in)
- .env.local, .env.development, .env.production
- README.md, *.md (documentation)
- .vscode, .idea (editor configs)
- dist, build, coverage (build artifacts)

Keep:
- package.json, package-lock.json (needed for install)
- tsconfig.json, next.config.ts (needed for build)
- prisma/ (schema and migrations)
- app/, lib/, public/ (source code)

This reduces build context size and speeds up Docker builds.
  </action>
  <verify>
```bash
cat .dockerignore | grep node_modules
cat .dockerignore | wc -l
```
File should exist with at least 10 exclusion patterns including node_modules, .next, .git, .env files.
  </verify>
  <done>
.dockerignore file exists with comprehensive exclusions for build artifacts, dependencies, and secrets
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Verify Dockerfile structure:
```bash
grep "FROM node" Dockerfile
grep "ENTRYPOINT" Dockerfile
grep "prisma" Dockerfile
```

2. Verify migration script:
```bash
cat scripts/migrate-and-start.sh | grep "prisma migrate deploy"
cat scripts/migrate-and-start.sh | grep "node.*server"
```

3. Verify .dockerignore:
```bash
cat .dockerignore | grep -E "(node_modules|\.next|\.env)"
```

4. Test Docker build:
```bash
docker build -t extensible-checklist:test .
```

Should complete without errors and produce working image.
</verification>

<success_criteria>
- Dockerfile exists with multi-stage build using node:alpine
- Migration script runs prisma migrate deploy before starting app
- .dockerignore excludes build artifacts and secrets
- Docker build completes successfully
- Image size is optimized (multi-stage build removes build dependencies)
- Requirements DEV-01 and partial DEV-07 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/07-production-deployment/07-01-SUMMARY.md`
</output>
