---
phase: 07-production-deployment
plan: 02
type: execute
wave: 2
depends_on: [07-01]
files_modified: [docker-compose.yml, app/api/health/route.ts]
autonomous: true

must_haves:
  truths:
    - "Application runs locally via docker-compose up"
    - "Health check endpoint returns 200 OK when app is healthy"
    - "Health check verifies database connectivity"
    - "App container connects to postgres container via Docker network"
  artifacts:
    - path: "docker-compose.yml"
      provides: "Local development orchestration"
      contains: "app:"
      min_lines: 30
    - path: "app/api/health/route.ts"
      provides: "Health check endpoint"
      exports: ["GET"]
      min_lines: 20
  key_links:
    - from: "docker-compose.yml"
      to: "Dockerfile"
      via: "build context"
      pattern: "build:.*context"
    - from: "app/api/health/route.ts"
      to: "prisma"
      via: "database query"
      pattern: "prisma\\.\\$.*raw"
    - from: "docker-compose.yml (app service)"
      to: "docker-compose.yml (postgres service)"
      via: "DATABASE_URL environment variable"
      pattern: "postgresql://.*postgres:5432"
---

<objective>
Enable local Docker development environment and create health check endpoint for deployment monitoring.

Purpose: Developers can run entire stack (app + database) with single docker-compose command. Health check endpoint allows container orchestrators (Docker Compose, Azure App Service) to verify application readiness and database connectivity.

Output: Updated docker-compose.yml with app service, health check API route for monitoring
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/07-production-deployment/07-CONTEXT.md
@.planning/phases/07-production-deployment/07-01-PLAN.md

# Current files
@docker-compose.yml
@.env.example

# Phase context decisions
- Use containerized PostgreSQL (not Azure managed service)
- DATABASE_URL uses Docker network hostname (service name)
- Health check returns 200 OK when app is running and DB is connected
- Brief downtime acceptable during deployment (no complex health check logic needed)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update docker-compose.yml with app service</name>
  <files>docker-compose.yml</files>
  <action>
Update existing docker-compose.yml to add application service alongside existing postgres service.

Add `app` service with:
- build:
  - context: . (current directory)
  - dockerfile: Dockerfile
- container_name: extensible-checklist-app
- ports: ["3000:3000"]
- environment:
  - DATABASE_URL: postgresql://johndoe:randompassword@postgres:5432/mydb
  - NEXTAUTH_URL: http://localhost:3000
  - NEXTAUTH_SECRET: dev-secret-change-in-production
- depends_on: [postgres]
- restart: unless-stopped
- healthcheck:
  - test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost:3000/api/health"]
  - interval: 30s
  - timeout: 10s
  - retries: 3
  - start_period: 40s

Note: Use service name `postgres` in DATABASE_URL (Docker network hostname resolution). Keep existing postgres service configuration unchanged.

The healthcheck uses wget (available in alpine) to hit health endpoint created in Task 2.
  </action>
  <verify>
```bash
cat docker-compose.yml | grep "app:"
cat docker-compose.yml | grep "healthcheck"
cat docker-compose.yml | grep "@postgres:5432"
```
Verify app service exists with build config, environment variables, postgres dependency, and healthcheck.
  </verify>
  <done>
docker-compose.yml includes app service that builds from local Dockerfile, connects to postgres via Docker network, includes healthcheck, and has all required environment variables
  </done>
</task>

<task type="auto">
  <name>Task 2: Create health check API endpoint</name>
  <files>app/api/health/route.ts</files>
  <action>
Create Next.js API route for health checking that verifies both application and database status.

Create at app/api/health/route.ts:

```typescript
import { NextResponse } from 'next/server';
import prisma from '@/lib/db';

export async function GET() {
  try {
    // Check database connectivity with simple query
    await prisma.$queryRaw`SELECT 1`;

    return NextResponse.json(
      {
        status: 'healthy',
        timestamp: new Date().toISOString(),
        database: 'connected'
      },
      { status: 200 }
    );
  } catch (error) {
    console.error('Health check failed:', error);

    return NextResponse.json(
      {
        status: 'unhealthy',
        timestamp: new Date().toISOString(),
        database: 'disconnected',
        error: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 503 }
    );
  }
}
```

Returns 200 OK when healthy, 503 Service Unavailable when database unreachable.

This endpoint will be called by:
- Docker healthcheck (local development)
- Azure App Service health check (production)
- External monitoring tools

Keep it lightweight - just verify connection, no complex logic.
  </action>
  <verify>
```bash
cat app/api/health/route.ts | grep "export async function GET"
cat app/api/health/route.ts | grep "prisma.*queryRaw"
cat app/api/health/route.ts | grep "503"
```
Verify route exports GET handler, queries database, returns 200 on success and 503 on failure.
  </verify>
  <done>
Health check endpoint exists at /api/health, returns 200 when database is connected, returns 503 when database is unavailable, and logs errors to console
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Verify docker-compose configuration:
```bash
cat docker-compose.yml | grep -A 20 "app:"
docker-compose config
```

2. Verify health endpoint code:
```bash
cat app/api/health/route.ts
```

3. Test local Docker setup:
```bash
docker-compose up --build
```

Once running, test health endpoint:
```bash
curl http://localhost:3000/api/health
```

Should return JSON with status: "healthy" and database: "connected".

4. Test app functionality:
Open http://localhost:3000 in browser and verify application works.

5. Check container health status:
```bash
docker ps
```
Should show app container with status "healthy" after start_period.
</verification>

<success_criteria>
- docker-compose.yml includes app service with build, environment, and healthcheck
- Health endpoint returns 200 OK when database connected
- Health endpoint returns 503 when database unavailable
- Running `docker-compose up` starts both postgres and app containers
- Application accessible at http://localhost:3000
- Health check accessible at http://localhost:3000/api/health
- Docker healthcheck reports container as healthy
- Requirements DEV-02, DEV-03, and partial DEV-07 satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/07-production-deployment/07-02-SUMMARY.md`
</output>
