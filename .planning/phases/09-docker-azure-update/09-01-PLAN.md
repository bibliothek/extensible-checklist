---
phase: 09-docker-azure-update
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [Dockerfile, scripts/migrate-and-start.sh, docker-compose.yml, .dockerignore]
autonomous: true

must_haves:
  truths:
    - "Docker container runs with SQLite database file"
    - "Database data persists across container restarts"
    - "Container can be built and started locally with working database"
  artifacts:
    - path: "Dockerfile"
      provides: "SQLite-compatible container build"
      contains: "DATABASE_URL"
    - path: "docker-compose.yml"
      provides: "Local container orchestration with volume mount"
      min_lines: 15
    - path: "scripts/migrate-and-start.sh"
      provides: "SQLite-aware migration entrypoint"
      contains: "prisma migrate deploy"
  key_links:
    - from: "Dockerfile"
      to: "prisma/dev.db"
      via: "volume mount configuration"
      pattern: "VOLUME|volume"
    - from: "scripts/migrate-and-start.sh"
      to: "DATABASE_URL"
      via: "environment variable validation"
      pattern: "DATABASE_URL"
---

<objective>
Verify Docker container works with SQLite and configure persistent volume mount for database file.

Purpose: Ensure containerized application uses SQLite correctly with data persistence across container restarts.
Output: Docker configuration that supports SQLite file-based database with volume mounting for local development and production readiness.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-database-migration/08-01-SUMMARY.md
@.planning/phases/07-production-deployment/07-01-SUMMARY.md

Phase 8 completed SQLite migration:
- Prisma schema uses sqlite provider
- DATABASE_URL format: "file:./prisma/dev.db"
- All application code works with SQLite

Phase 7 established Docker foundation:
- Multi-stage Dockerfile with Prisma migrations
- Migration entrypoint script (migrate-and-start.sh)
- Non-root user (nextjs:1001)

Current state:
- Dockerfile copies Prisma schema/migrations but assumes PostgreSQL connection string
- No volume mount configured for SQLite database file
- Migration script expects remote DATABASE_URL, not file path
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Dockerfile for SQLite compatibility</name>
  <files>Dockerfile</files>
  <action>
Review and verify Dockerfile is SQLite-compatible. The current Dockerfile from Phase 7 already:
- Copies Prisma schema and migrations to /app/prisma
- Installs Prisma CLI for migrations
- Runs migrate-and-start.sh entrypoint

Ensure the Dockerfile does NOT hardcode PostgreSQL-specific configurations. The DATABASE_URL environment variable should be provided at runtime, not build time.

Add comment documenting that DATABASE_URL must be provided as environment variable with format "file:/app/data/dev.db" for SQLite.

No structural changes needed - Phase 8 migration already made schema SQLite-compatible. This task is verification + documentation.
  </action>
  <verify>
Review Dockerfile line-by-line:
- Confirm no PostgreSQL-specific dependencies (pg-native, libpq-dev, etc.)
- Confirm Prisma schema copying is present
- Confirm DATABASE_URL is expected as runtime environment variable
- Confirm no hardcoded database connection strings
  </verify>
  <done>
Dockerfile reviewed and confirmed SQLite-compatible. Comments added documenting DATABASE_URL format for SQLite deployment.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create docker-compose.yml for local development</name>
  <files>docker-compose.yml</files>
  <action>
Create docker-compose.yml file in project root providing local container orchestration with SQLite volume mount.

Configuration:
- Service name: app
- Build from local Dockerfile
- Port mapping: 3000:3000
- Environment variables:
  - DATABASE_URL=file:/app/data/dev.db
  - NEXTAUTH_URL=http://localhost:3000
  - NEXTAUTH_SECRET=local-dev-secret-not-for-production
- Volume mount: ./data:/app/data
  - Maps local ./data directory to container /app/data
  - SQLite database file persists in ./data/dev.db on host
  - Survives container restarts and rebuilds
- Restart policy: unless-stopped

Add .gitignore entry for /data directory (contains database file, should not be committed).

Purpose: Developers can run `docker-compose up` for instant local development with persistent SQLite database.
  </action>
  <verify>
Run commands:
1. `docker-compose config` - validates YAML syntax
2. Review output confirms volume mount at ./data:/app/data
3. Review output confirms DATABASE_URL points to /app/data/dev.db

Check .gitignore contains /data entry.
  </verify>
  <done>
docker-compose.yml created with volume mount for SQLite persistence. Configuration validated. .gitignore updated to exclude /data directory.
  </done>
</task>

<task type="auto">
  <name>Task 3: Test Docker build and run with SQLite</name>
  <files>README.md</files>
  <action>
Test complete Docker workflow with SQLite database persistence.

Steps:
1. Build Docker image: `docker-compose build`
2. Start container: `docker-compose up -d`
3. Wait 10 seconds for startup and migrations
4. Check logs: `docker-compose logs` - verify migrations ran successfully
5. Test database persistence:
   - Create test user via signup API: `curl -X POST http://localhost:3000/api/auth/signup -H "Content-Type: application/json" -d '{"email":"docker-test@example.com","password":"testpass123"}'`
   - Verify response is successful (201 or 200)
   - Stop container: `docker-compose down`
   - Verify ./data/dev.db file exists on host
   - Restart container: `docker-compose up -d`
   - Wait 10 seconds
   - Check logs again - verify migrations detected existing database (no re-initialization)
   - Verify database file size unchanged (data persisted)
6. Clean up: `docker-compose down`

Update README.md with "Docker Development" section documenting:
- Prerequisites: Docker and Docker Compose installed
- Commands: `docker-compose up` to start, `docker-compose down` to stop
- Database location: ./data/dev.db (persisted on host)
- Environment variables can be overridden in docker-compose.yml
  </action>
  <verify>
Check test results:
- Docker build completed without errors
- Container started successfully
- Migration logs show "Migrations completed successfully"
- Signup API returned success response
- ./data/dev.db file exists and has non-zero size
- After restart, database retained test user data
- README.md has new "Docker Development" section with docker-compose commands
  </verify>
  <done>
Docker build and run tested with SQLite. Database persistence verified across container restarts. README.md updated with Docker development instructions.
  </done>
</task>

</tasks>

<verification>
Run complete verification workflow:

1. **Clean state test:**
   - Delete ./data directory if exists
   - Run `docker-compose build`
   - Run `docker-compose up -d`
   - Verify container starts and migrations create new database

2. **Persistence test:**
   - Create test data via API
   - Restart container
   - Verify data still exists

3. **Documentation test:**
   - Follow README.md Docker Development section step-by-step
   - Verify instructions are accurate and complete
</verification>

<success_criteria>
- Docker container builds successfully with SQLite configuration
- Container starts and runs Prisma migrations against SQLite file
- Database file persists in mounted volume across container restarts
- docker-compose.yml provides working local development environment
- README.md documents Docker development workflow clearly
- No PostgreSQL dependencies remain in Docker configuration
</success_criteria>

<output>
After completion, create `.planning/phases/09-docker-azure-update/09-01-SUMMARY.md` following the summary template at `.claude/get-shit-done/templates/summary.md`.

Include:
- Verification results from persistence testing
- docker-compose.yml configuration details
- Any issues encountered with volume mounting on Windows/Mac vs Linux
- Confirmation that DOCK-01, DOCK-02, DOCK-03 requirements are met
</output>
